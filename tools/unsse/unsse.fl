%option always-interactive

%{

#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

struct {
  char* id;
  char* event;
  char* data;
} buf = {0,0,0};

struct {
  const char* id;
  const char* event;
  const char* data;
} msg = {0,0,0};

/*
 * skip the first character in string, if there is one;
 * then replace the string in \a *pTarget with this string;
 * return a pointer to the string.
 */ 
static void do_set(char** pBuf, const char* string)
{
    *pBuf = realloc(*pBuf, strlen(string) + 1);
    strcpy(*pBuf, string);
}

static void do_add(char** pBuf, const char* string)
{
  if(!*pBuf) {
    do_set(pBuf, string);
  } 
  else {
    *pBuf = realloc(*pBuf, strlen(*pBuf) + strlen(string) + 1);
    strcat(*pBuf, "\n");
    strcat(*pBuf, string);
  }
}

#define set(name, ptr) do { do_set(&buf.name, ptr); msg.name = buf.name; } while(0)

#define add(name, ptr) do { do_add(&buf.name, ptr); msg.name = buf.name; } while(0)

static void onEvent(const char* event, const char* id, const char* data);

static void flush()
{
    if(!msg.data) return;
    
    if(!msg.event)
      msg.event = "event";
    if(!msg.id)
      msg.id = "id";
    
    printf("event '%s'\n", msg.event);
    printf("id '%s'\n", msg.id);
    printf("data '%s'\n", msg.data);
    
    onEvent(msg.event, msg.id, msg.data);
    msg.event = msg.id = msg.data = NULL;
}
        
%}

%%

id:\ .*         set(id, yytext + 4);
id:.*           set(id, yytext + 3);
event:\ .*      set(event, yytext + 7);
event:.*        set(event, yytext + 6);
data:\ .*       add(data, yytext + 6);
data:.*         add(data, yytext + 5);

.*              { flush(); }
\n              { flush(); }

%%

#define HELP "sse-client connects to an URL, expects a server sent event stream, and runs a command on each event.\n\n" \
  "  sse-client URL command [ <option1> [ <option2> ... ] ]\n\n" \
  "The command to be called will receive event type and id as additional parameters; e.g. as\n\n" \
  "  command option1 option2 event id\n\n" \
  "and will receive data input on STDIN."

static void help() {
  fprintf(stderr, "sse-client, compiled %s %s.\n\n", __DATE__, __TIME__);
  fprintf(stderr, "%s\n", HELP);

  exit(1);
}

/* 
 * The command and command_ofs parameter keep the command to call.
 * This process will receive the event and id parameters as arguments;
 * i.e. when you run
 *
 *   unsse http://localhost:12567/abc process_events
 *
 * the process_events command will be called with parameters
 *
 *   process_events event id
 *
 * and the data part will be written to process_events STDIN.
 */
static char** command = NULL;
static unsigned command_ofs = 0;

/*
 * process the event.
 */
#define READ 0
#define WRITE 1

static void onEvent(const char* event, const char* id, const char* data)
{
  command[command_ofs] = (char*)event;
  command[command_ofs+1] = (char*)id;
  
  pid_t pid = fork();
  if (pid == -1) { 
    perror("fork");
    exit(1);
  }
  
  int p_stdin[2];
  if (pipe(p_stdin) != 0) {
    perror("pipe");
    exit(1);
  }
  
  if (pid == 0) {
    /* code for child */

    close(p_stdin[WRITE]);
    dup2(p_stdin[READ], READ);

    {
      fprintf(stderr, "Running");

      const char** c = command;
      while(*c) {
        fprintf(stderr, " %s", *c);
        c++;
      }
      fprintf(stderr, "\n");
    }

    execvp(command[0], command);
    perror(command[0]);
    
    _exit(1);  /* the execvp() failed - a failed child should not flush parent files */
  }
  else { /* code for parent */ 
    fprintf(stderr, "pid of latest child is %d\n", pid);
    
    write(p_stdin[WRITE], data, strlen(data));
    close(p_stdin[WRITE]);

    fprintf(stderr, "wrote to child\n");
    
    int status = 0;
    waitpid(pid, &status, 0);
    
    if(WIFEXITED(status)) {
      fprintf(stderr, "child exited with stats %d\n", WEXITSTATUS(status));
    }
    else if(WIFSIGNALED(status)) {
      fprintf(stderr, "child exited because of signal %d\n", WTERMSIG(status));
    }
  }
}

int main(int argc, const char** argv) 
{
  (void)yyunput; // Suppress warning about unused symbol
  
  const char* url = NULL;
  
  argv++; argc--;
  
  /* == process url ================================================ */

  if(*argv) {
    url = *argv++;
    argc--;
  }

  /* == process command ============================================ */
  
  if(*argv) {
    /* Keep space for event, id, and data */
    command = calloc(argc + 4, sizeof(const char*));
    
    command_ofs = 0;
    while(*argv) {
      command[command_ofs++] = strdup(*argv++);
      argc--;
    }
  }

  /* == help needed? =============================================== */
  
  if(!command)
    help();
    
  char* curl = 0;
  asprintf(&curl, "curl -N -s -S %s", url);

  fprintf(stderr, "running %s\n", curl);
  
  yyin = popen(curl, "r");
  setlinebuf(yyin);
  
  while(yylex());

  return 0;
}

int yywrap() { 
  return 1; 
}

