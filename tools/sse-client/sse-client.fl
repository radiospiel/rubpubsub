%option always-interactive

%{

#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

struct {
  char* id;
  char* event;
  char* data;
} buf = {0,0,0};

struct {
  const char* id;
  const char* event;
  const char* data;
} msg = {0,0,0};

/*
 * skip the first character in string, if there is one;
 * then replace the string in \a *pTarget with this string;
 * return a pointer to the string.
 */ 
static void do_set(char** pBuf, const char* string)
{
    *pBuf = realloc(*pBuf, strlen(string) + 1);
    strcpy(*pBuf, string);
}

static void do_add(char** pBuf, const char* string)
{
  if(!*pBuf) {
    do_set(pBuf, string);
  } 
  else {
    *pBuf = realloc(*pBuf, strlen(*pBuf) + strlen(string) + 1);
    strcat(*pBuf, "\n");
    strcat(*pBuf, string);
  }
}

#define set(name, ptr) do { do_set(&buf.name, ptr); msg.name = buf.name; } while(0)

#define add(name, ptr) do { do_add(&buf.name, ptr); msg.name = buf.name; } while(0)

static void onEvent(const char* event, const char* id, const char* data);

static void flush()
{
    if(!msg.data) return;
    
    if(!msg.event)
      msg.event = "event";
    if(!msg.id)
      msg.id = "id";
    
    onEvent(msg.event, msg.id, msg.data);

    msg.event = msg.id = msg.data = NULL;
    buf.event = buf.id = buf.data = NULL;
}

%}

%%

id:\ .*         set(id, yytext + 4);
id:.*           set(id, yytext + 3);
event:\ .*      set(event, yytext + 7);
event:.*        set(event, yytext + 6);
data:\ .*       add(data, yytext + 6);
data:.*         add(data, yytext + 5);

.*              { flush(); }
\n              { flush(); }

%%

#define HELP "sse-client connects to an URL, expects a server sent event stream, and runs a command on each event.\n\n" \
  "  sse-client URL command [ <option1> [ <option2> ... ] ]\n\n" \
  "The command to be called will receive event type and id as additional parameters; e.g. as\n\n" \
  "  command option1 option2 event id\n\n" \
  "and will receive data input on STDIN."

static void help() {
  fprintf(stderr, "sse-client, compiled %s %s.\n\n", __DATE__, __TIME__);
  fprintf(stderr, "%s\n", HELP);

  exit(1);
}

/* 
 * The command and command_ofs parameter keep the command to call.
 * This process will receive the event and id parameters as arguments;
 * i.e. when you run
 *
 *   unsse http://localhost:12567/abc process_events
 *
 * the process_events command will be called with parameters
 *
 *   process_events event id
 *
 * and the data part will be written to process_events STDIN.
 */
static char** command = NULL;
static unsigned command_ofs = 0;

/*
 * process the event.
 */
#define READ 0
#define WRITE 1

static void die(const char* msg) {
  perror(msg); exit(1);
}

static int write_all(int fd, const void* data, unsigned dataLen) {
  int len = 0;
  while(len < dataLen) {
    int written = write(fd, data, dataLen);
    if(written < 0)
      return -1;
      
    data += written;
    dataLen -= written;
    len += written;
  }
  
  return len;
}

static void onEvent(const char* event, const char* id, const char* data)
{
  // prepare command.
  command[command_ofs] = (char*)event;
  command[command_ofs+1] = (char*)id;

  // Prepare pipe for subprocess
  int fd[2];
  if (pipe(fd) != 0) die("pipe");
  
  // Start subprocess
  pid_t pid = fork();
  if (pid == -1) die("fork");
  
  if (pid == 0) { /* the child */
    close(fd[WRITE]);
    dup2(fd[READ], READ);

    execvp(command[0], command);
    perror(command[0]);
    
    _exit(1);  /* the execvp() failed - a failed child should not flush parent files */
  }
  else { /* code for parent */ 
    close(fd[READ]);

    write_all(fd[WRITE], data, strlen(data));
    write_all(fd[WRITE], "\n", 1);
    close(fd[WRITE]);
    
    int status = 0;
    waitpid(pid, &status, 0);
    
    // Show results if something broke.
    if(WIFEXITED(status) && WEXITSTATUS(status) != 0)
      fprintf(stderr, "child exited with stats %d\n", WEXITSTATUS(status));
    else if(WIFSIGNALED(status))
      fprintf(stderr, "child exited of signal %d\n", WTERMSIG(status));
  }
}

int main(int argc, const char** argv) 
{
  (void)yyunput; // Suppress warning about unused symbol
  
  const char* url = NULL;
  
  argv++; argc--;
  
  /* == process url ================================================ */

  if(*argv) {
    url = *argv++;
    argc--;
  }

  /* == process command ============================================ */
  
  if(*argv) {
    /* Keep space for event, id, and data */
    command = calloc(argc + 4, sizeof(const char*));
    
    command_ofs = 0;
    while(*argv) {
      command[command_ofs++] = strdup(*argv++);
      argc--;
    }
  }

  /* == help needed? =============================================== */
  
  if(!command)
    help();
    
  char* curl = 0;
  asprintf(&curl, "curl -N -s -S %s", url);

  fprintf(stderr, "running %s\n", curl);
  
  yyin = popen(curl, "r");
  setlinebuf(yyin);
  
  while(yylex());

  return 0;
}

int yywrap() { 
  return 1; 
}

